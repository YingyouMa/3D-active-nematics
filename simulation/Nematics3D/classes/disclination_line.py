import numpy as np 

from ..disclination import add_mid_points_disclination, calc_coord, get_plane, is_defects_connected, smoothen_line, sort_line_indices
from .smoothened_line import SmoothenedLine

dict_figure_simplify = {'bgcolor': ('parent.parent.parent.parent.parent.scene', 'background'),
                        'tube_radius': ('parent.parent.filter', 'radius')
                        }


class DisclinationLine:
    """
    Disclination_line class represents a disclination line.


    """
    def __init__(self, defect_indices, 
                       if_sorted=True, origin=(0,0,0), space_index_ratio=1, if_add_mid=True):   
        '''
        defect_indices : array, (M,3)
                         The array that includes all the indices of defects.
                         For each defect, one of the indices should be integer and the rest should be half-integer.
                         Usually defect_indices are generated by defect_defect() in this module.

        if_sorted : bool, optional
                    if the defects are already sorted that the neighboring defects have the minimum distance.
                    Default is True. Because this class is usually used after defect_classify_into_lines() and extract_lines() 

        origin : array of three floats, optional
                 Origin of the line, translating the whole line in real space
                 Default is (0, 0, 0), as the line is not translated 

        space_index_ratio : float or array of three floats, optional
                            Ratio between the unit of real space to the unit of grid indices.
                            If the box size is N x M x L and the size of grid of n and S is n x m x l,
                            then space_index_ratio should be (N/n, M/m, L/l).
                            If a single float x is provided, it is interpreted as (x, x, x).
                            Default is 1.

        Dependencies
        ------------
        - NumPy: 1.22.0
        '''
        if if_sorted == False:
            defect_indices = sort_line_indices(defect_indices) 

        self.__defect_indices = defect_indices
        self.__is_loop = is_defects_connected(defect_indices[0], defect_indices[-1])

        if len(np.shape([space_index_ratio])) == 1:
            space_index_ratio = (space_index_ratio, space_index_ratio, space_index_ratio)

        if if_add_mid:
            self.__defect_indices_full = add_mid_points_disclination(self.__defect_indices, is_loop=self.__is_loop)
        else:
            self.__defect_indices_full = self.__defect_indices

        self.__defect_coord = calc_coord(self.__defect_indices_full, 
                                         origin=origin, space_index_ratio=space_index_ratio)
        self.__origin = origin
        self.__space_index_raio = space_index_ratio

    def update_defect_coord(self, origin=(0,0,0), space_index_ratio=1):

        self.__defect_coord = calc_coord(self.__defect_indices_full, 
                                         origin=origin, space_index_ratio=space_index_ratio)

        self.__origin = origin
        self.__space_index_raio = space_index_ratio 

    def update_norm(self):
        self.__norm = get_plane(self.__defect_coord)
        return self.__norm

    def update_center(self):
        self.__center = np.average(self.__defect_indices, axis=0)
        return self.__center

    def update_smoothen(self,
                        window_ratio=3, window_length=None, order=3, N_out_ratio=3):
        if self.__is_loop == True:
            smoothen_mode = 'wrap'
        else:
            smoothen_mode = 'interp'

        output = SmoothenedLine(self.__defect_coord, 
                                window_ratio=window_ratio, window_length=window_length, 
                                order=order, N_out_ratio=N_out_ratio, mode=smoothen_mode,
                                is_keep_origin=False)
        
        self.__defect_coord_smooth_object = output
        self.__defect_coord_smooth = output.output

    @property
    def defect_coord_smooth(self):
        return self.__defect_coord_smooth


    def figure_init(self,
                    tube_radius=0.25, tube_opacity=0.5, tube_color=(0.5,0.5,0.5), tube_sides=6,
                    if_norm=False, 
                    norm_coord=[None,None,None], norm_color=(0,0,1), norm_length=20, 
                    norm_opacity=0.5, norm_width=1.0, norm_orient=1,
                    is_new=True, bgcolor=(1,1,1)
                    ):
        '''

        '''
        from mayavi import mlab

        if hasattr(self, 'defect_coord_smooth'):
            line_coord = self.defect_coord_smooth
        else:
            line_coord = self.__defect_coord
        
        if self.__is_loop == True:
            line_coord = np.concatenate([line_coord, [line_coord[0]]])

        if is_new:
            mlab.figure(bgcolor=bgcolor)
        figure = mlab.plot3d(*(line_coord.T), 
                             tube_radius=tube_radius, opacity=tube_opacity, color=tube_color, tube_sides=tube_sides)
        if not is_new:
            figure.parent.parent.parent.parent.parent.scene.background = bgcolor
        
        self.figure = figure
        

    def figure_update(self, **kwargs):

        dict_figure_simplify = {'bgcolor': (self.figure.parent.parent.parent.parent.parent.scene, 'background'),
                                'tube_radius': (self.figure.parent.parent.filter, 'radius')
                        }
        
        for attr in kwargs.keys():
            obj = dict_figure_simplify.get(attr)[0]
            attr_final = dict_figure_simplify.get(attr)[1]
            setattr(obj, attr_final, kwargs.get(attr))
        




def plot_loop(
            loop_coord, 
            tube_radius=0.25, tube_opacity=0.5, tube_color=(0.5,0.5,0.5), if_add_head=True,
            if_norm=False, 
            norm_coord=[None,None,None], norm_color=(0,0,1), norm_length=20, 
            norm_opacity=0.5, norm_width=1.0, norm_orient=1,
            print_load_mayavi=False
            ):

    if print_load_mayavi == True:
        now = time.time()
        from mayavi import mlab
        print(f'loading mayavi cost {round(time.time()-now, 2)}s')
    else:
        from mayavi import mlab

    if if_add_head==True:
        loop_coord = np.concatenate([loop_coord, [loop_coord[0]]])

    mlab.plot3d(*(loop_coord.T), tube_radius=tube_radius, opacity=tube_opacity, color=tube_color)

    if if_norm == True:
        loop_N = get_plane(loop_coord) * norm_orient
        loop_center = loop_coord.mean(axis=0)
        for i, coord in enumerate(norm_coord):
            if coord != None:
                loop_center[i] = coord
        mlab.quiver3d(
        *(loop_center), *(loop_N),
        mode='arrow',
        color=norm_color,
        scale_factor=norm_length,
        opacity=norm_opacity,
        line_width=norm_width
        ) 
