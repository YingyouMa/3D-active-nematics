import numpy as np 

from ..disclination import add_mid_points_disclination, calc_coord, get_plane, is_defects_connected, sort_line_indices
from .smoothened_line import SmoothenedLine
from ..general import array_from_single_or_list

class DisclinationLine:
    """
    Disclination_line class represents a disclination line.


    """
    def __init__(self, defect_indices, box_size,
                       is_sorted=True, origin=(0,0,0), space_index_ratio=1, is_add_mid=True):   
        '''
        defect_indices : array, (M,3)
                         The array that includes all the indices of defects.
                         For each defect, one of the indices should be integer and the rest should be half-integer.
                         Usually defect_indices are generated by defect_defect() in this module.

        box_size : float or numpy of three floats
                   The largest index of the entire box in each dimension.
                   If box_size is one integer as x, it is interprepted as (x,x,x).
                   This is useful for periodic boudanry condition because defects might be out of box.
                   For non-periodic boudanry condition, it could be set as values bigger than the maximum indices of defects in each dimension, or simply [np.inf, np.inf, np.inf]

        is_sorted : bool, optional
                    if the defects are already sorted that the neighboring defects have the minimum distance.
                    Default is True. Because this class is usually used after defect_classify_into_lines() and extract_lines() 

        origin : array of three floats, optional
                 Origin of the line, translating the whole line in real space
                 Default is (0, 0, 0), as the line is not translated 

        space_index_ratio : float or array of three floats, optional
                            Ratio between the unit of real space to the unit of grid indices.
                            If the box size is N x M x L and the size of grid of n and S is n x m x l,
                            then space_index_ratio should be (N/n, M/m, L/l).
                            If a single float x is provided, it is interpreted as (x, x, x).
                            Default is 1.

        Dependencies
        ------------
        - NumPy: 1.22.0
        '''
        if is_sorted == False:
            defect_indices = sort_line_indices(defect_indices) 

        self._defect_indices = defect_indices
        self._origin = origin
        self._space_index_ratio = array_from_single_or_list(space_index_ratio)
        self._box_size = array_from_single_or_list(box_size)
        self._is_loop = is_defects_connected(defect_indices[0], defect_indices[-1])
        self._defect_num = np.shape(self._defect_indices)[0]

        if len(np.shape([space_index_ratio])) == 1:
            space_index_ratio = (space_index_ratio, space_index_ratio, space_index_ratio)

        if is_add_mid:
            self._defect_indices_full = add_mid_points_disclination(self._defect_indices, is_loop=self._is_loop)
        else:
            self._defect_indices_full = self._defect_indices
        
        self._defect_coord = calc_coord(self._defect_indices_full, 
                                         origin=origin, space_index_ratio=space_index_ratio)
        self._origin = origin
        self._space_index_ratio = space_index_ratio

    def update_defect_coord(self, origin=(0,0,0), space_index_ratio=1):

        self._defect_coord = calc_coord(self._defect_indices_full, 
                                         origin=origin, space_index_ratio=space_index_ratio)

        self._origin = origin
        self._space_index_ratio = space_index_ratio 

    def update_norm(self):
        self._norm = get_plane(self._defect_coord)
        return self._norm

    def update_center(self):
        self._center = np.average(self._defect_indices, axis=0)
        return self._center

    def update_smoothen(self,
                        window_ratio=3, window_length=None, order=3, N_out_ratio=3):
        if self._is_loop == True:
            smoothen_mode = 'wrap'
        else:
            smoothen_mode = 'interp'

        output = SmoothenedLine(self._defect_coord, 
                                window_ratio=window_ratio, window_length=window_length, 
                                order=order, N_out_ratio=N_out_ratio, mode=smoothen_mode,
                                is_keep_origin=False)
        
        self._defect_coord_smooth_obj = output
        self._defect_coord_smooth = output._output

    def dict_figure_simplify_generate(self):
        result = {'bgcolor':        (lambda: self.figure.parent.parent.parent.parent.parent.scene, 'background'),
                  'tube_radius':    (lambda: self.figure.parent.parent.filter, 'radius'),
                  'tube_opacity':   (lambda: self.figure.actor.property, 'opacity'),
                  'tube_sides':     (lambda: self.figure.parent.parent.filter, 'number_of_sides'),
                  'tube_color':     (lambda: self.figure.actor.actor.property, 'color')
                        }
        return result

    def figure_init(self,
                    tube_radius=0.25, tube_opacity=0.5, tube_color=(0.5,0.5,0.5), tube_sides=6,
                    is_new=True, bgcolor=(1,1,1)
                    ):
        #! plot_norm
        '''

        '''
        from mayavi import mlab

        if hasattr(self, '_defect_coord_smooth'):
            line_coord = self._defect_coord_smooth
        else:
            line_coord = self._defect_coord
        
        if self._is_loop == True:
            line_coord = np.concatenate([line_coord, [line_coord[0]]])

        if is_new:
            mlab.figure(bgcolor=bgcolor)
        figure = mlab.plot3d(*(line_coord.T), 
                             tube_radius=tube_radius, opacity=tube_opacity, color=tube_color, tube_sides=tube_sides)
        if not is_new:
            figure.parent.parent.parent.parent.parent.scene.background = bgcolor
        
        self.figure = figure
        self.dict_figure_simplify = {'bgcolor':      (lambda: self.figure.parent.parent.parent.parent.parent.scene, 'background'),
                                     'tube_radius':  (lambda: self.figure.parent.parent.filter, 'radius'),
                                     'tube_opacity': (lambda: self.figure.actor.property, 'opacity'),
                                     'tube_sides':   (lambda: self.figure.parent.parent.filter, 'number_of_sides'),
                                     'tube_color':   (lambda: self.figure.actor.actor.property, 'color')
                                             }

    def figure_check_parameter(self, *args):
        for arg in args:
            temp = self.dict_figure_simplify.get(arg)
            obj = temp[0]()
            attr = temp[1]
            print(arg + ' : ' + str(getattr(obj,attr)))

    def figure_update(self, **kwargs):
        for attr in kwargs.keys():
            obj = self.dict_figure_simplify.get(attr)[0]()
            attr_final = self.dict_figure_simplify.get(attr)[1]
            setattr(obj, attr_final, kwargs.get(attr))
        




# def plot_loop(
#             loop_coord, 
#             tube_radius=0.25, tube_opacity=0.5, tube_color=(0.5,0.5,0.5), if_add_head=True,
#             if_norm=False, 
#             norm_coord=[None,None,None], norm_color=(0,0,1), norm_length=20, 
#             norm_opacity=0.5, norm_width=1.0, norm_orient=1,
#             print_load_mayavi=False
#             ):

#     if print_load_mayavi == True:
#         now = time.time()
#         from mayavi import mlab
#         print(f'loading mayavi cost {round(time.time()-now, 2)}s')
#     else:
#         from mayavi import mlab

#     if if_add_head==True:
#         loop_coord = np.concatenate([loop_coord, [loop_coord[0]]])

#     mlab.plot3d(*(loop_coord.T), tube_radius=tube_radius, opacity=tube_opacity, color=tube_color)

#     if if_norm == True:
#         loop_N = get_plane(loop_coord) * norm_orient
#         loop_center = loop_coord.mean(axis=0)
#         for i, coord in enumerate(norm_coord):
#             if coord != None:
#                 loop_center[i] = coord
#         mlab.quiver3d(
#         *(loop_center), *(loop_N),
#         mode='arrow',
#         color=norm_color,
#         scale_factor=norm_length,
#         opacity=norm_opacity,
#         line_width=norm_width
#         ) 
